&emsp;&emsp;计算机的编码问题归根结底就是设计一套扩展性强、空间效率高的方案，来表示现实世界各类语言的各类字符。
### 历史因素
&emsp;&emsp;在计算机普及的初始阶段是没有编码问题的，英文世界日常的语言因素包含52个大小写字母，数字0-9，!@#$%^&等符号，总数在100个左右。所以*ASCII*(American Stand Code For Information Interchange)编码方案在一开始很愉快地被使用着。  
&emsp;&emsp;ASCII规定了128个字符，包括可打印和不可打印字符，每个字符对应一个数字。在类Unix操作系统下可以用`man ascii`命令查看完整的字符集。128个字符只需7bit就足够了，对于一字节来说，剩下的1bit常用于通讯系统中的校验和纠错。C语言的char类型使用的就是ASCII码，每个字符占一个字节，所以C语言不能将中文赋值给*char*类型。  
&emsp;&emsp;但是当计算机向世界范围扩散时问题就来了：例如德语、法语都有自己的字母，和ASCII码不兼容，所以要为这些语言设计一套新的编码方案。中日韩三国的文字因为文字数量过于庞大就更难处理了。  
&emsp;&emsp;以中文编码方案GBK为例，1个字节根本无法存储所有的汉字，所以至少要用2个字节，这个编码方案的基本思路是将所有汉字分成若干张表，通过高位bit查找到汉字所在的表，通过低位bit查找到汉字在表中的位置，这样就能定位到这个汉字。  
&emsp;&emsp;这些编码方案只能解决一门语言的编码问题，致命缺陷在于**如果一篇文章中使用了多门语言，就无法判断应该使用哪一种编码方案，也就无法同时展示多种语言**。

### Unicode
&emsp;&emsp;Unicode(uniform code)字符集(character set)的推出结束了不同语言需要不同编码方案这样混乱的局面。
#### 核心思路
&emsp;&emsp;它的核心思路在于**将字符集和字符编码解耦**。在此之前的所有编码方案都是直接将字符在字符集中的位置(或者说是编号)作为字符的编码，也就是作为计算机中对应的字节流。这就导致扩展性非常差，设计一个编码方案时只会将事先考虑好的语言囊括进去，而不会再考虑加入新的字符。  
&emsp;&emsp;Unicode将所有语言分成多个平面(plane)，其中最重要的是**BMP**(Basic Multilingaul Plane)，这个平面囊括了当今世界所有常用语言，而其他平面上有的是远古的文字，有的还空着，如果未来有新的语言发明可以用这些空的平面。  
&emsp;&emsp;BMP的大小为16bit，即2字节，能存储2的16次方(65536)个字符。BMP上所有的字符有一个自己专属的码点(code point)，相当于一个数字。这是字符的专属身份证号。通常用4个16进制的数表示，其中前128个字符和ASCII码相同。  
&emsp;&emsp;举例来说，字符'a'，在ASCII中对应16进制*0x61*，在Unicode字符集中为*U+0061*  
&emsp;&emsp;Java的char类型使用的就是unicode字符集，长度为2个字节，基本上能表示一切字符，所以非常适合跨平台。要注意的是，这是指JVM内部用UTF-16存储字符，但是Java源码文件是可以用其他编码方案(UTF-8，GBK)存储的。  
&emsp;&emsp;Unicode仅仅是一个字符集，它给了全世界通用语言的每个字符一个身份证号码。但是它没有规定这些字符该如何在计算机中用0和1表示。  
### 编码方案
#### UTF-16
&emsp;&emsp;既然给了每个字符一个独一无二的身份证号码，那么理所当然能用这个号码作为字符在计算中的编码。UTF-16统一用16bit(2字节)作为字符的编码，但是它的缺点在于如果这个字符的码点很小，高位都是0。例如a的码点为U+0061，它的前8位都是0，这对于存储是巨大的浪费。所以UTF-16未能大范围推广。
#### UTF-8
&emsp;&emsp;UTF-8（8-bits Unicode Transformation Forma）是UTF-16的改良版，它的编码方式如下：

```
   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

1. 对于一个字节的字符，也就是ASCII字符，起始bit为0，后续7位组成这个字符的Unicode码
2. 对于n个字节的字符，第一个字节的前n位为1，第n+1位为0；后续的字节均以10开头，其余未提及的bit组成字符的Unicode码

&emsp;&emsp;UTF-8在多种语言间取得了平衡，尤其是获得了英文世界的支持，所以成为了互联网信息交换的标准编码方案。  
&emsp;&emsp;URL的中文编码是UTF-8的常见应用场景: %作为字节的分隔符，2个16进制数表示一字节。

```
JavaScript

input： decodeURI("%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81")
output： 字符编码

intput： decodeURI("%E5%AD%97")
output： 字
```